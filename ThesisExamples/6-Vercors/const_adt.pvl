// Axiomatic data type declaration for a const pointer of type A
adt const_pointer<A> {
 // Constructor of the pointer. The sequence b holds the actual values as pointer block.
 // For a pointer we keep track of the offset.
 pure const_pointer<A> const_pointer_of(seq<A> b, int offset); //~@\label{line:pointer-constructor}@
 // Get the underlying values (the pointer block)
 pure seq<A> const_pointer_block(const_pointer<A> p);
 // Get the offset
 pure int const_pointer_offset(const_pointer<A> p);

 // the block offset must be valid wrt the length of the block
 axiom (\forall const_pointer<A> p;
  const_pointer_offset(p) >= 0 &&
   const_pointer_offset(p) < |const_pointer_block(p)|);

 // const_pointer_of is injective: a (block, offset) pair indicates a unique
 // const_pointer value
 axiom (\forall seq<A> b, int offset;
  {:const_pointer_block(const_pointer_of(b, offset)):} == b &&
  {:const_pointer_offset(const_pointer_of(b, offset)):} == offset);
}

 // Get the value at the offset from the block
 decreases;
pure A const_ptr_deref<A>(const_pointer<A> p) =
 const_pointer<A>.const_pointer_block(p)[
  const_pointer<A>.const_pointer_offset(p)];

 // Create a new pointer, by increasing the offset
 decreases;
 requires 0 <= const_pointer<A>.const_pointer_offset(p) + offset;
 requires const_pointer<A>.const_pointer_offset(p) + offset < |
  const_pointer<A>.const_pointer_block(p)|;
pure const_pointer<A> const_ptr_add<A>(const_pointer<A> p, int offset) =
  const_pointer<A>.const_pointer_of(
     const_pointer<A>.const_pointer_block(p),
     const_pointer<A>.const_pointer_offset(p) + offset);