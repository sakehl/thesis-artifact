  requires a>0;
  ensures \result == 2*a && \result>0;
pure int f(int a) {
  return 2*a;
}

  context a != null && a.length == 1;
  context Perm(a[0], write);
  requires a[0] > 0;
  ensures a[0] == 2*\old(a[0]) && a[0]>0;
void g(int[] a) {
  a[0] = 2*a[0];
}

  context_everywhere (x != null && x.length==n);
  context_everywhere (\forall* int i; 0<=i && i<n;Perm(x[i], 1\1));
  ensures (\forall int j; 0<=j && j<n; x[j] == j);
  decreases;
void enumerate(int[] x, int n){
    loop_invariant 0 <= i && i <= n;
    loop_invariant (\forall int j; 0<=j && j<i; x[j] == j);
    decreases n-i;
  for(int i=0; i<n;i++){
  	x[i] = i;
  	assert x[i] == i;
  }
}

class LinkedList {
  int value;
  LinkedList next;
}

resource state(LinkedList l) = Perm(l.value, write) ** Perm(l.next, write) **
  (l != null ==> state(l.next)) ** l.value>=0 ;

  requires l != null ** state(l);
  ensures \result >= 0;
int sum(LinkedList l) {
  int s = 0;
  LinkedList p = l;

    loop_invariant state(p);
    loop_invariant s >= 0;
  while(p != null) {
    unfold state(p);
    s = s + p.value;
    p = p.next;
  }

  return s;
}

 context_everywhere a != null && a.length == n;
 context (\forall* int i=0..n; Perm(a[i], write));
 ensures (\forall int i=0..n; a[i] == \old(a[n-i-1]));
 decreases;
void reverse(int[] a, int n){
 par threads(int tid=0..n) //|\label{ex4:par}|
   requires Perm(a[tid], 1\2);
   requires Perm(a[n-tid-1], 1\2);
   ensures Perm(a[tid], write);
   ensures a[tid] == \old(a[n-tid-1]);
 {
   int old = a[n-tid-1];
   barrier(threads)
    requires Perm(a[n-tid-1], 1\2);
    ensures Perm(a[tid], 1\2);
   {}
   a[tid] = old;
 }
}